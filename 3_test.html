<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematische Canvas-Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0f0f0f;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <script>
      const canvas = document.getElementById('backgroundCanvas');
      const ctx = canvas.getContext('2d');
      document.body.appendChild(canvas);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Helper function to resize canvas on window resize
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
      
      // Generate random points in the plane
      const points = Array.from({ length: 50 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
      }));
      
      // Compute the convex hull using Graham's scan algorithm
      function computeConvexHull(points) {
        // Sort points by x-coordinate (and y-coordinate as a tiebreaker)
        points.sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
      
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
      
        const lower = [];
        for (const p of points) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
            lower.pop();
          }
          lower.push(p);
        }
      
        const upper = [];
        for (const p of points.slice().reverse()) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
            upper.pop();
          }
          upper.push(p);
        }
      
        // Remove the last point of each half because it's repeated
        upper.pop();
        lower.pop();
      
        return lower.concat(upper);
      }
      
      // Animate the points and convex hull
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      
        // Update points with random motion
        points.forEach(p => {
          p.x += (Math.random() - 0.5) * 2;
          p.y += (Math.random() - 0.5) * 2;
      
          // Keep points inside the canvas
          p.x = Math.max(0, Math.min(canvas.width, p.x));
          p.y = Math.max(0, Math.min(canvas.height, p.y));
        });
      
        // Compute the convex hull
        const hull = computeConvexHull(points);
      
        // Draw points
        ctx.fillStyle = 'rgba(0, 150, 255, 0.8)';
        points.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      
        // Draw convex hull
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < hull.length; i++) {
          const p = hull[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.closePath();
        ctx.stroke();
      
        requestAnimationFrame(animate);
      }
      
      animate();
      
        </script>
</body>
</html>

