<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematische Canvas-Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0f0f0f;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <script>const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
document.body.appendChild(canvas);
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Helper function to resize canvas on window resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// Generate two sets of random points
const pointsA = Array.from({ length: 10 }, () => ({
  x: Math.random() * canvas.width / 2,
  y: Math.random() * canvas.height / 2,
  vx: (Math.random() - 0.5) * 0.5,
  vy: (Math.random() - 0.5) * 0.5
}));

const pointsB = Array.from({ length: 10 }, () => ({
  x: Math.random() * canvas.width / 2 + canvas.width / 2,
  y: Math.random() * canvas.height / 2 + canvas.height / 2,
  vx: (Math.random() - 0.5) * 0.5,
  vy: (Math.random() - 0.5) * 0.5
}));

// Compute the convex hull using Graham's scan algorithm
function computeConvexHull(points) {
  // Sort points by x-coordinate (and y-coordinate as a tiebreaker)
  points.sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);

  const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

  const lower = [];
  for (const p of points) {
    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
      lower.pop();
    }
    lower.push(p);
  }

  const upper = [];
  for (const p of points.slice().reverse()) {
    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
      upper.pop();
    }
    upper.push(p);
  }

  // Remove the last point of each half because it's repeated
  upper.pop();
  lower.pop();

  return lower.concat(upper);
}

// Compute Minkowski sum of two convex hulls
function computeMinkowskiSum(hullA, hullB) {
  const sum = [];
  for (const a of hullA) {
    for (const b of hullB) {
      sum.push({ x: a.x + b.x, y: a.y + b.y });
    }
  }
  return computeConvexHull(sum);
}

// Animate the points and convex hulls
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update points with smooth motion
  const updatePoints = points => {
    points.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;

      // Reverse velocity if points hit the canvas boundary
      if (p.x <= 0 || p.x >= canvas.width) p.vx *= -1;
      if (p.y <= 0 || p.y >= canvas.height) p.vy *= -1;
    });
  };

  updatePoints(pointsA);
  updatePoints(pointsB);

  // Compute convex hulls
  const hullA = computeConvexHull(pointsA);
  const hullB = computeConvexHull(pointsB);

  // Compute Minkowski sum
  const minkowskiHull = computeMinkowskiSum(hullA, hullB);

  // Draw points
  const drawPoints = (points, color) => {
    ctx.fillStyle = color;
    points.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
  };

  drawPoints(pointsA, 'rgba(0, 150, 255, 0.8)');
  drawPoints(pointsB, 'rgba(0, 255, 150, 0.8)');

  // Draw convex hulls
  const drawHull = (hull, color) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < hull.length; i++) {
      const p = hull[i];
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.closePath();
    ctx.stroke();
  };

  drawHull(hullA, 'rgba(255, 100, 100, 0.9)');
  drawHull(hullB, 'rgba(100, 255, 100, 0.9)');
  drawHull(minkowskiHull, 'rgba(255, 255, 0, 0.9)');

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>

